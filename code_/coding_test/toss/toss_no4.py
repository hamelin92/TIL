def solution(s, times):
    limit = [999999, 24, 60, 60]
    # 초에서 분, 분에서 시간, 시간에서 날짜로 변하는 값, 날짜 -> 월로 변하는 값은 필요가 없기떄문에 값에 영향을 주지 못하는 큰 수치로 지정한다.
    T = len(times)
    s = list(map(int, s.split(':'))) # 첫 저축 시점과 이후 저축 시간 간격을 :을 뺴고 정수값의 리스트로 변환한다.
    first_day = last_day = s[2] # 첫 저축날짜, 최근저축날짜(초기값)를 따로 저장한다.
    every_save = 1 # 1일 1저축을 지켰는지 확인하는 변수이다.
    times = [list(map(int, times[i].split(':'))) for i in range(T)]
    for t in times: # 각각의 저축 시간 간격에 대해 순회
        for i in range(1,5): # 초 -> 분 -> 시간 -> 날 순서로 순회한다.
            s[-i] += t[4-i] # s에 저축 간격 값을 자리에 맞게 더해준다 ( 초, 분 , 시간, 날 순서)
            if s[6-i] >= limit[4-i]: # 더한 후에 각 자리가 처음에 지정한 limit값을 넘으면 자리를 올려준다.
                s[6-i] -= limit[4-i]
                s[5-i] += 1
        if s[2] - last_day <= 1: # 만약 최근 저축 날짜와 현재 저축 날짜의 차이가 1 이하라면 최근 저축 날짜를 현재로 갱신한다.
            last_day = s[2]
        else: # 그외의 경우 , 즉 2 이상 차이나는 경우 1일 1저축은 실패이므로 every_save에 0을 저장
            every_save = 0
    else: # 모든 저축이 끝나고 마지막 날짜를 구한다.
        final = s[2]
    answer = [every_save, final-first_day+1]
    return answer
print(solution("2021:04:12:16:08:35",["01:06:30:00", "01:04:12:00"]))



'''
문제 설명
처음으로 저축한 날짜부터 마지막으로 저축한 날짜까지 매일 1회 이상 저축을 했다면 1일 1저축에 성공했다고 판단합니다. 예를 들어,
첫 번째 저축을 2021년 4월 12일 오후 4시 8분 35초에 하고,
두 번째 저축을 1일 6시간 30분뒤인 2021년 4월 13일 오후 10시 38분 35초에 하고,
마지막 저축을 1일 4시간 12분뒤인 2021년 4월 15일 오전 2시 50분 35초에 했다면,

4월 14일에는 저축을 하지 않았기 때문에 1일 1저축은 실패입니다.
첫 저축 날짜는 4월 12일이고, 마지막 저축 날짜는 4월 15일이므로, 저축 기간은 4일입니다.
저축 기간은 첫 저축 날짜부터 마지막 저축 날짜까지 포함하여 그 사이 모든 날짜를 저축 유무와 상관없이 한 번씩 센 기간입니다.
만약,
첫 번째 저축을 2021년 4월 12일 오후 4시 8분 35초에 하고,
두 번째 저축을 1일 6시간 30분뒤인 2021년 4월 13일 오후 10시 38분 35초에 하고,
마지막 저축을 0일 1시간 12분뒤인 2021년 4월 13일 오후 11시 50분 35초에 했다면,

4월 12월부터 4월 13일까지 매일 1회 이상 저축을 했기 때문에, 1일 1저축은 성공입니다.
첫 저축 날짜는 4월 12일이고, 마지막 저축 날짜는 4월 13일이므로, 저축 기간은 2일입니다.
첫 저축을 시작한 시각인 문자열 s, 다음 저축까지 걸린 기간을 담은 문자열 배열 times가 주어집니다. 이때 1일 1저축의 성공 여부와 저축 기간(일)을 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

제한사항
문제를 간단하게 하기 위해, 윤년은 없으며 모든 달은 30일이 마지막 날이라고 가정합니다. 따라서, 1년은 360일입니다.

return 값 형식

길이 2인 정수형 배열을 return 합니다.
[1일 1저축의 성공 여부, 저축한 기간]을 return 합니다.
첫 번째 원소로 1일 1저축에 성공했다면 1을, 성공하지 못했다면 0을 담습니다.
두 번째 원소로 저축 기간(일)을 담습니다.
s는 YYYY:MM:DD:HH:mm:SS 형태로, 길이가 11인 문자열입니다.

YYYY는 년도를 뜻합니다. 1년은 0001:MM:DD:HH:mm:SS 형태로 주어집니다.
1 ≤ YYYY ≤ 9999
MM은 월을 뜻합니다. 1월은 YYYY:01:DD:HH:mm:SS 형태로 주어집니다.
1 ≤ MM ≤ 12
DD는 일을 뜻합니다. 1일은 YYYY:MM:01:HH:mm:SS 형태로 주어집니다.
1 ≤ DD ≤ 30
HH는 시를 뜻합니다. 오전 1시는 YYYY:MM:DD:01:mm:SS 형태로 주어집니다.
0 ≤ HH ≤ 23
mm은 분을 뜻합니다. 1분은 YYYY:MM:DD:HH:01:SS 형태로 주어집니다.
0 ≤ mm ≤ 59
SS는 초를 뜻합니다. 1초는 YYYY:MM:DD:HH:mm:01 형태로 주어집니다.
0 ≤ SS ≤ 59
예를 들어, 1년 1월 1일 오전 1시 1분 1초는 0001:01:01:01:01:01 형태로 주어집니다. 2021년 11월 30일 오후 10시 4분 24초는 2021:11:30:22:04:24형태로 주어집니다.
0 ≤ times의 길이 ≤ 1,000

times의 원소는 DD:HH:mm:SS의 형태로 주어집니다.

DD는 일을 뜻합니다. 1일은 01:HH:mm:SS 형태로 주어집니다.
0 ≤ DD ≤ 99
HH는 시를 뜻합니다. 1시간은 DD:01:mm:SS 형태로 주어집니다.
0 ≤ HH ≤ 23
mm은 분을 뜻합니다. 1분은 DD:HH:01:SS 형태로 주어집니다.
0 ≤ mm ≤ 59
SS는 초를 뜻합니다. 1초는 DD:HH:mm:01 형태로 주어집니다.
0 ≤ SS ≤ 59
예를 들어, 0일 2시간 5분 18초는 00:02:05:18 형태로 주어집니다.
마지막 저축 시각이 9999년을 초과하는 입력은 주어지지 않습니다.

입출력 예
s	times	result
"2021:04:12:16:08:35"	["01:06:30:00", "01:04:12:00"]	[0, 4]
"2021:04:12:16:08:35"	["01:06:30:00", "00:01:12:00"]	[1, 2]
"2021:04:12:16:10:42"	["01:06:30:00"]	[1, 2]
"2021:04:12:16:08:35"	["01:06:30:00", "01:01:12:00", "00:00:09:25"]	[1, 4]
입출력 예 설명
입출력 예 #1

문제 첫 번째 예시와 같습니다.

1일 1저축을 실패했습니다. 저축 기간은 4월 12일 ~ 4월 15일, 총 4일입니다.

따라서 정답은 [0, 4]입니다.

입출력 예 #2

문제 두 번째 예시와 같습니다.

1일 1저축을 성공했습니다. 저축 기간은 4월 12일 ~ 4월 13일, 총 2일입니다.

따라서 정답은 [1, 2]입니다.

입출력 예 #3

첫 번째 저축은 2021년 4월 12일 오후 4시 10분 42초에 합니다.
두 번째 저축은 1일 6시간 30분뒤인 2021년 4월 13일 오후 10시 40분 42초에 합니다.
4월 12일과 4월 13일 모두 저축을 했기 때문에 1일 1저축에 성공했습니다. 저축기간은 4월 12일 ~ 4월 13일, 총 2일입니다.

따라서 정답은 [1, 2]입니다.

입출력 예 #4

첫 번째 저축은 2021년 4월 12일 오후 4시 8분 35초에 합니다.
두 번째 저축은 1일 6시간 30분뒤인 2021년 4월 13일 오후 10시 38분 35초에 합니다.
세 번째 저축은 1일 1시간 12분뒤인 2021년 4월 14일 오후 11시 50분 35초에 합니다.
네 번째 저축은 0일 0시간 9분 25초뒤인 2021년 4월 15일 오전 0시 0분 0초에 합니다.
4월 12일부터 4월 15일까지 모두 저축을 했기 때문에 1일 1저축에 성공했습니다. 저축기간은 4월 12일 ~ 4월 15일, 총 4일입니다.

따라서 정답은 [1, 4]입니다.
'''